=== Directory Content Listing ===
Excluded: node_modules, out, .next directories and .db files
===============================

FILE: ./README-CSV-IMPORT.md
----------------------------------------
# CSV Product Import

## Overview
The bakery backend now includes functionality to import product data from a CSV file located in the `content/products/products.csv` path. This feature automatically populates the database with product information during application startup if no products exist in the database.

## Implementation Details

### Key Files Added/Modified

1. **New Utility File**: `utils/csvParser.js`
   - Provides CSV parsing functionality
   - Handles quoted CSV values properly
   - Returns array of JSON objects from CSV data

2. **Updated Product Model**: `models/product.js`
   - Added `image` field to store product image paths
   - Added `category` field to store product category

3. **Updated Product Seeder**: `seeders/productSeeder.js`
   - Now reads data from CSV file instead of hardcoded values
   - Maps CSV fields to database model fields
   - Sets default values for fields not present in CSV (stock, dailyTarget)

4. **Updated Product Controller**: `controllers/productController.js`
   - Modified to include new fields in API responses

## CSV File Format

The expected format for `products.csv` is:
```
id,name,category,image,price
1,"Product Name",Category,"/path/to/image.jpg",2.50
```

## Running the Import

The product import happens automatically when the application starts if the product table is empty. The import process follows these steps:

1. Application starts and connects to the database
2. Database tables are synced
3. Product seeder checks if products exist in the database
4. If no products exist, the seeder reads and parses the CSV file
5. CSV data is transformed to match the database schema
6. Products are created in the database via `bulkCreate`

## Testing CSV Parsing

A test script has been added to verify the CSV parsing functionality:

```bash
npm run test:csv
```

This script:
- Reads the CSV file
- Parses it into JSON objects
- Displays the first 3 products for verification
- Shows how the data is transformed for database insertion

## Troubleshooting

- If products aren't being imported, check that the CSV file exists at `content/products/products.csv`
- Verify CSV format matches the expected structure
- Check logs for any parsing errors
- Make sure the database connection is working properly----------------------------------------

FILE: ./README.md
----------------------------------------
# Bakery Backend
This repository contains the backend API for a bakery application. It's built using Node.js, Express, and Sequelize ORM with a SQLite database. The backend provides authentication functionality (register/login), cash management for tracking daily revenue, and a chat system for communication. The codebase follows a structured MVC (Model-View-Controller) pattern for better organization and maintainability.

## Architecture

bakery backend/
│
├── config/
│   └── database.js         # Database configuration
│
├── controllers/
│   ├── authController.js   # Authentication logic
│   ├── cashController.js   # Cash entry logic
│   └── chatController.js   # Chat message logic
│
├── middleware/
│   ├── authMiddleware.js   # Authentication middleware
│   └── loggerMiddleware.js # Request logging middleware
│
├── models/
│   ├── index.js            # Model definitions and relationships
│   ├── User.js             # User model
│   ├── Cash.js             # Cash model
│   └── Chat.js             # Chat model
│
├── routes/
│   ├── authRoutes.js       # Authentication routes
│   ├── cashRoutes.js       # Cash routes
│   └── chatRoutes.js       # Chat routes
│
├── utils/
│   └── logger.js           # Logging utility
│
└── index.js                # Main application entry
----------------------------------------

FILE: ./ai.md
----------------------------------------
# Bakery Backend Overview

This directory contains the Node.js backend for the bakery management system. It's built using Express, Sequelize ORM with a SQLite database.

## Project Structure

- `config/` - Database configuration 
- `controllers/` - Request handlers and business logic
- `middleware/` - Express middleware (auth, logging)
- `models/` - Sequelize data models
- `routes/` - API route definitions
- `seeders/` - Database seed data
- `utils/` - Utility functions and helpers

## Key Features

- REST API for product management
- CSV product import from content/products directory
- User authentication and authorization
- Cash management system
- Chat functionality

## Recent Updates

The backend now supports importing product data from CSV files:
- Added CSV parser utility in `utils/csvParser.js`
- Updated product model to include image and category fields
- Modified product seeder to read from CSV instead of hardcoded values
- Added test script for CSV parsing in `test-csv.js`

## API Endpoints

- Authentication: `/login`, `/register` 
- Products: `/products`, `/products/:id`
- Orders: `/orders`
- Baking List: `/baking-list`
- Cash: `/cash`
- Chat: `/chat`

## Code Style

- No semicolons
- MVC architecture
- Async/await pattern for asynchronous operations
- Proper error handling
- Sequelize for database operations

## Getting Started

Run `npm install` to install dependencies and `npm start` to start the server. The server will run on port 5000 by default.----------------------------------------

FILE: ./bakery/processes/croissant_production.yaml
----------------------------------------
# Croissant Production Workflow
name: croissant_production
version: 1.2
steps:
  - name: teig_vorbereiten
    timeout: 45m
    activities:
      - mixen
      - kneten
      - buttereinschlagen
    notes: "Kühlen Sie die Butter auf 8°C herunter"
  - name: erste_gehzeit
    type: sleep
    duration: 2h
    conditions:
      - temp > 22°C: 1.5h
      - temp < 18°C: 2.5h
    location: "Kühlraum"
  - name: laminieren
    timeout: 30m
    activities:
      - ausrollen
      - falten
      - kühlen
    repeat: 3
    notes: "Nach jedem Durchgang 20 Minuten kühlen"
  - name: zweite_gehzeit
    type: sleep
    duration: 1h
    location: "Kühlraum"
  - name: formen
    timeout: 30m
    activities:
      - ausrollen
      - schneiden
      - rollen
  - name: final_proofing
    type: sleep
    duration: 1.5h
    conditions:
      - temp > 25°C: 1h
  - name: backen
    timeout: 18m
    params:
      temp: 190°C
    notes: "Vorher mit Ei bestreichen"
----------------------------------------

FILE: ./bakery/processes/filling_production.yaml
----------------------------------------
# Fillings Production Workflow
name: filling_production
version: 1.0
fillings:
  - name: nuss_fuellung
    ingredients:
      - 2kg Haselnüsse (gemahlen)
      - 1kg Zucker
      - 500g Butter
      - 4 Eier
      - 200ml Rum (optional)
    yield: 3.5kg
    preparation_time: 25m

  - name: schoko_fuellung
    ingredients:
      - 1.5kg Schokolade (Zartbitter)
      - 500g Butter
      - 500g Zucker
      - 200g Kakaopulver
    yield: 2.7kg
    preparation_time: 20m

  - name: pudding_fuellung
    ingredients:
      - 2L Milch
      - 8 Päckchen Vanillepuddingpulver
      - 500g Zucker
      - 4 Eigelb
    yield: 2.5kg
    preparation_time: 30m

  - name: marzipan_fuellung
    ingredients:
      - 2kg Marzipanrohmasse
      - 500g Puderzucker
      - 200g Butter
      - 100ml Amaretto (optional)
    yield: 2.7kg
    preparation_time: 15m
----------------------------------------

FILE: ./bakery/processes/hefeteig_production.yaml
----------------------------------------
# Hefeteig Base Production Workflow
name: hefeteig_production
version: 1.0
steps:
  - name: zutaten_vorbereiten
    timeout: 15m
    activities:
      - mehl_abwiegen
      - zucker_abwiegen
      - butter_vorbereiten
      - hefe_aktivieren
    notes: "Milch auf 30-35°C erwärmen für die Hefeaktivierung"

  - name: teig_herstellen
    timeout: 30m
    activities:
      - mixen
      - kneten
    params:
      knetzeit: "12m bei mittlerer Stufe"
    notes: "Teig sollte glatt und elastisch sein"

  - name: erste_gehzeit
    type: sleep
    duration: 45m
    conditions:
      - temp > 25°C: 30m
      - temp < 20°C: 60m
    notes: "Abgedeckt an einem warmen Ort gehen lassen"

  - name: teig_portionieren
    timeout: 25m
    activities:
      - teig_abwiegen
      - teig_formen
    params:
      einheit_groesse: 300g
    notes: "Gleichmäßige Portionen für konsistente Backwaren"

  - name: zweite_gehzeit
    type: sleep
    duration: 20m
    notes: "Kurze Gehzeit vor der Weiterverarbeitung"
----------------------------------------

FILE: ./bakery/processes/sourdough_bread.yaml
----------------------------------------
# Sourdough Bread Production
name: sourdough_bread
version: 1.0
steps:
  - name: starter_füttern
    timeout: 15m
    activities:
      - mischen
    notes: "Sauerteig im Verhältnis 1:1:1 (Starter:Mehl:Wasser) füttern"
  - name: starter_reifen
    type: sleep
    duration: 8h
    conditions:
      - temp < 20°C: 10h
    notes: "Starter sollte sich verdoppeln"
  - name: teig_mischen
    timeout: 30m
    activities:
      - mehl_wiegen
      - wasser_zugeben
      - salz_zugeben
      - mischen
  - name: autolyse
    type: sleep
    duration: 1h
  - name: kneten_und_falten
    timeout: 30m
    activities:
      - kneten
      - stretch_and_fold
  - name: erste_gehzeit
    type: sleep
    duration: 4h
    conditions:
      - temp > 26°C: 3h
  - name: vorformen
    timeout: 15m
  - name: ruhen
    type: sleep
    duration: 30m
  - name: formen
    timeout: 15m
    notes: "In Gärkörbchen legen"
  - name: final_proofing
    type: sleep
    duration: 12h
    location: "Kühlschrank"
  - name: backen
    timeout: 45m
    activities:
      - vorheizen
      - einschneiden
      - backen
    params:
      temp: 230°C
      dampf: true
    notes: "Erste 25 Min mit Dampf, dann ohne"
----------------------------------------

FILE: ./config/database.js
----------------------------------------
const { Sequelize } = require("sequelize");
const logger = require("../utils/logger");

logger.info("Initializing Sequelize with SQLite database...");

// Initialize Sequelize with SQLite
const sequelize = new Sequelize({
  dialect: "sqlite",
  storage: "database.db",
  logging: (msg) => logger.db(`${msg}`), // Log SQL queries
});

// Function to test database connection
const testConnection = async () => {
  try {
    await sequelize.authenticate();
    logger.info("Database connection established successfully.");
    return true;
  } catch (error) {
    logger.error("Unable to connect to the database:", error);
    return false;
  }
};

module.exports = {
  sequelize,
  testConnection,
};
----------------------------------------

FILE: ./controllers/ai.md
----------------------------------------
# Bakery Backend Controllers Directory

This directory contains the controller logic for the bakery application, following the MVC (Model-View-Controller) architecture pattern. Controllers handle HTTP requests, interact with models, and send back appropriate responses.

## Key Controllers

- `productController.js` - Handles product-related operations (list, view, create, update, delete)
- `authController.js` - Manages user authentication (register, login)
- `cashController.js` - Manages cash entries and financial transactions
- `chatController.js` - Handles chat message operations
- `orderController.js` - Manages customer orders

## Product Controller

The `productController.js` contains:

- `getProducts` - Retrieves all active products with fields like id, name, price, stock, description, image, and category
- `getProduct` - Retrieves a specific product by ID with all its details

This controller was recently updated to include new fields (image, category) in the API response after the product model was expanded to support CSV data import.

## Controller Structure

Each controller typically follows this pattern:
- Import required models and utilities
- Export controller methods as functions
- Use async/await pattern for database operations
- Include proper error handling and logging
- Return appropriate HTTP status codes and response data

## Request Flow

1. Route receives HTTP request
2. Controller method is called
3. Controller performs business logic (often involving models)
4. Controller sends HTTP response with appropriate data

## Code Style

- No semicolons
- Async/await for asynchronous operations
- Consistent error handling with logger
- Clear separation of concerns
- RESTful API design principles

## Usage Example

```javascript
// Route definition
router.get('/products', productController.getProducts);

// Controller implementation
exports.getProducts = async (req, res) => {
  try {
    const products = await models.Product.findAll({
      where: { isActive: true },
      attributes: ['id', 'name', 'price', 'stock', 'description', 'image', 'category'],
    });
    res.json(products);
  } catch (error) {
    logger.error("Error retrieving products:", error);
    res.status(500).json({ error: "Database error" });
  }
};
```----------------------------------------

FILE: ./controllers/authController.js
----------------------------------------
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const { User } = require("../models");
const logger = require("../utils/logger");
const { SECRET_KEY } = require("../middleware/authMiddleware");

// Register new user
exports.register = async (req, res) => {
  logger.info("Processing registration request...");
  try {
    const { username, password } = req.body;
    logger.info(`Attempting to register user: ${username}`);

    const hashedPassword = await bcrypt.hash(password, 10);
    logger.info("Password hashed successfully");

    const newUser = await User.create({
      username,
      password: hashedPassword,
    });

    logger.info(`User created successfully with ID: ${newUser.id}`);
    res.json({ message: "User created" });
  } catch (error) {
    logger.error("Registration error:", error);

    if (error.name === "SequelizeUniqueConstraintError") {
      logger.info("Registration failed: Username already exists");
      return res.status(400).json({ error: "User exists" });
    }
    res.status(500).json({ error: "Server error" });
  }
};

// Login user
exports.login = async (req, res) => {
  logger.info("Processing login request...");
  try {
    const { username, password } = req.body;
    logger.info(`Login attempt for user: ${username}`);

    const user = await User.findOne({ where: { username } });

    if (!user) {
      logger.info(`Login failed: User ${username} not found`);
      return res.status(400).json({ error: "Invalid credentials" });
    }

    logger.info(`User found with ID: ${user.id}, validating password...`);
    const validPassword = await bcrypt.compare(password, user.password);

    if (!validPassword) {
      logger.info(`Login failed: Invalid password for user ${username}`);
      return res.status(400).json({ error: "Invalid credentials" });
    }

    logger.info(`Password valid, generating token for user ${username}`);
    const token = jwt.sign({ id: user.id }, SECRET_KEY);
    logger.info("Login successful");
    res.json({ token });
  } catch (error) {
    logger.error("Login error:", error);
    res.status(500).json({ error: "Server error" });
  }
};
----------------------------------------

FILE: ./controllers/bakingListController.js
----------------------------------------
const models = require("../models");
const { Op } = require("sequelize");
const logger = require("../utils/logger");

// Generate baking list for a specific date
exports.getBakingList = async (req, res) => {
  logger.info("Processing baking list request...");
  try {
    // Get the requested date or default to today
    const requestDate =
      req.query.date || new Date().toISOString().split("T")[0];
    logger.info(`Generating baking list for date: ${requestDate}`);

    // Start and end of the requested date
    const dayStart = new Date(requestDate);
    const dayEnd = new Date(requestDate);
    dayEnd.setHours(23, 59, 59, 999);

    // Get all active orders for the date
    const orders = await models.Order.findAll({
      where: {
        pickupDate: {
          [Op.between]: [dayStart, dayEnd],
        },
        status: {
          [Op.in]: ["Pending", "Confirmed"],
        },
      },
      include: [{ model: models.OrderItem }],
    });

    logger.info(`Found ${orders.length} orders for date ${requestDate}`);

    // Get all products
    const products = await models.Product.findAll({
      where: { isActive: true },
    });

    // Calculate quantities needed for shop inventory
    const shopItems = products.map((product) => ({
      productId: product.id,
      name: product.name,
      dailyTarget: product.dailyTarget,
      currentStock: product.stock,
      shopQuantity: Math.max(0, product.dailyTarget - product.stock),
    }));

    // Calculate quantities needed for orders
    const orderItemsMap = {};
    orders.forEach((order) => {
      order.OrderItems.forEach((item) => {
        if (!orderItemsMap[item.productId]) {
          orderItemsMap[item.productId] = {
            productId: item.productId,
            name: item.productName,
            orderQuantity: 0,
          };
        }
        orderItemsMap[item.productId].orderQuantity += item.quantity;
      });
    });

    // Combine shop and order requirements
    const allItemsMap = {};

    // Add shop items first
    shopItems.forEach((item) => {
      allItemsMap[item.productId] = {
        ...item,
        orderQuantity: 0,
        totalQuantity: item.shopQuantity,
      };
    });

    // Add order items
    Object.values(orderItemsMap).forEach((item) => {
      if (!allItemsMap[item.productId]) {
        // Product only in orders, not in shop inventory
        allItemsMap[item.productId] = {
          productId: item.productId,
          name: item.name,
          shopQuantity: 0,
          orderQuantity: item.orderQuantity,
          totalQuantity: item.orderQuantity,
        };
      } else {
        // Product in both shop and orders
        allItemsMap[item.productId].orderQuantity = item.orderQuantity;
        allItemsMap[item.productId].totalQuantity += item.orderQuantity;
      }
    });

    // Format order data for the response
    const formattedOrders = orders.map((order) => ({
      orderId: order.id,
      customerName: order.customerName,
      pickupDate: order.pickupDate,
      status: order.status,
      notes: order.notes,
      items: order.OrderItems.map((item) => ({
        productId: item.productId,
        productName: item.productName,
        quantity: item.quantity,
      })),
    }));

    logger.info("Baking list generated successfully");
    res.json({
      date: requestDate,
      allItems: Object.values(allItemsMap),
      shopItems: shopItems,
      orderItems: formattedOrders,
    });
  } catch (error) {
    logger.error("Error generating baking list:", error);
    res.status(500).json({ error: "Error generating baking list" });
  }
};
----------------------------------------

FILE: ./controllers/cashController.js
----------------------------------------
const { Cash } = require("../models");
const logger = require("../utils/logger");

// Add cash entry
exports.addCashEntry = async (req, res) => {
  logger.info("Processing cash entry request...");
  try {
    const { amount } = req.body;
    const date = new Date().toISOString().split("T")[0];
    logger.info(
      `Adding cash entry: ${amount} for user ${req.userId} on ${date}`,
    );

    const cashEntry = await Cash.create({
      UserId: req.userId,
      amount,
      date,
    });

    logger.info(`Cash entry created with ID: ${cashEntry.id}`);
    res.json({ message: "Cash entry saved" });
  } catch (error) {
    logger.error("Cash entry creation error:", error);
    res.status(500).json({ error: "Database error" });
  }
};

// Get cash entries for user
exports.getCashEntries = async (req, res) => {
  logger.info("Processing get cash entries request...");
  try {
    const entries = await Cash.findAll({
      where: { UserId: req.userId },
      order: [["date", "DESC"]],
    });

    logger.info(
      `Retrieved ${entries.length} cash entries for user ${req.userId}`,
    );
    res.json(entries);
  } catch (error) {
    logger.error("Error retrieving cash entries:", error);
    res.status(500).json({ error: "Database error" });
  }
};
----------------------------------------

FILE: ./controllers/chatController.js
----------------------------------------
const { Chat, User } = require("../models");
const logger = require("../utils/logger");

// Get all chat messages
exports.getChatMessages = async (req, res) => {
  logger.info("Processing chat messages retrieval request...");
  try {
    logger.info("Querying for chat messages with user info...");
    const messages = await Chat.findAll({
      include: [{ model: User, attributes: ["username"] }],
      order: [["timestamp", "ASC"]],
    });

    logger.info(`Retrieved ${messages.length} chat messages`);
    res.json(messages);
  } catch (error) {
    logger.error("Chat retrieval error:", error);
    res.status(500).json({ error: "Database error" });
  }
};

// Add a new chat message
exports.addChatMessage = async (req, res) => {
  logger.info("Processing new chat message request...");
  try {
    const { message } = req.body;
    logger.info(
      `Adding message from user ${req.userId}: "${message.substring(0, 20)}${message.length > 20 ? "..." : ""}"`,
    );

    const chatMessage = await Chat.create({
      UserId: req.userId,
      message,
      timestamp: new Date(),
    });

    logger.info(`Chat message created with ID: ${chatMessage.id}`);
    res.json({ message: "Message saved" });
  } catch (error) {
    logger.error("Chat message creation error:", error);
    res.status(500).json({ error: "Database error" });
  }
};
----------------------------------------

FILE: ./controllers/orderController.js
----------------------------------------
const models = require("../models");
const logger = require("../utils/logger");

// Get all orders
exports.getOrders = async (req, res) => {
  console.log("Processing get all orders request...");
  logger.info("Processing get all orders request...");
  try {
    const orders = await models.Order.findAll({
      include: [{ model: models.OrderItem }],
      order: [["createdAt", "DESC"]],
    });

    logger.info(`Retrieved ${orders.length} orders`);
    res.json(orders);
  } catch (error) {
    logger.error("Order retrieval error:", error);
    res.status(500).json({ error: "Database error" });
  }
};

// Get a specific order
exports.getOrder = async (req, res) => {
  logger.info(`Processing get order request for ID: ${req.params.id}`);
  try {
    const order = await models.Order.findByPk(req.params.id, {
      include: [{ model: models.OrderItem }],
    });

    if (!order) {
      logger.warn(`Order not found: ${req.params.id}`);
      return res.status(404).json({ message: "Order not found" });
    }

    logger.info(`Order ${req.params.id} retrieved successfully`);
    res.json(order);
  } catch (error) {
    logger.error(`Error retrieving order ${req.params.id}:`, error);
    res.status(500).json({ error: "Database error" });
  }
};

// Create a new order
exports.createOrder = async (req, res) => {
  logger.info("Processing create order request...");
  try {
    const {
      customerName,
      customerPhone,
      customerEmail,
      pickupDate,
      status,
      notes,
      items,
      totalPrice,
    } = req.body;

    logger.info(`Creating order for customer: ${customerName}`);

    // Create order in transaction to ensure all items are saved
    const result = await models.sequelize.transaction(async (t) => {
      // Create the order
      const order = await models.Order.create(
        {
          customerName,
          customerPhone,
          customerEmail,
          pickupDate,
          status,
          notes,
          totalPrice,
        },
        { transaction: t },
      );

      // Create all order items
      if (items && items.length > 0) {
        const orderItems = items.map((item) => ({
          OrderId: order.id,
          productId: item.productId,
          productName: item.productName,
          quantity: item.quantity,
          unitPrice: item.unitPrice,
        }));

        await models.OrderItem.bulkCreate(orderItems, { transaction: t });
      }

      return order;
    });

    logger.info(`Order created with ID: ${result.id}`);

    // Fetch the complete order with items to return
    const createdOrder = await models.Order.findByPk(result.id, {
      include: [{ model: models.OrderItem }],
    });

    res.status(201).json(createdOrder);
  } catch (error) {
    logger.error("Order creation error:", error);
    res
      .status(500)
      .json({ error: "Error creating order", details: error.message });
  }
};

// Update an order
exports.updateOrder = async (req, res) => {
  logger.info(`Processing update order request for ID: ${req.params.id}`);
  try {
    const {
      customerName,
      customerPhone,
      customerEmail,
      pickupDate,
      status,
      notes,
      items,
      totalPrice,
    } = req.body;

    // Find the order
    const order = await models.Order.findByPk(req.params.id);

    if (!order) {
      logger.warn(`Order not found for update: ${req.params.id}`);
      return res.status(404).json({ message: "Order not found" });
    }

    // Update in transaction
    await models.sequelize.transaction(async (t) => {
      // Update order details
      await order.update(
        {
          customerName,
          customerPhone,
          customerEmail,
          pickupDate,
          status,
          notes,
          totalPrice,
        },
        { transaction: t },
      );

      // Delete existing items
      await models.OrderItem.destroy({
        where: { OrderId: order.id },
        transaction: t,
      });

      // Create new items
      if (items && items.length > 0) {
        const orderItems = items.map((item) => ({
          OrderId: order.id,
          productId: item.productId,
          productName: item.productName,
          quantity: item.quantity,
          unitPrice: item.unitPrice,
        }));

        await models.OrderItem.bulkCreate(orderItems, { transaction: t });
      }
    });

    logger.info(`Order ${req.params.id} updated successfully`);

    // Fetch updated order with items
    const updatedOrder = await models.Order.findByPk(req.params.id, {
      include: [{ model: models.OrderItem }],
    });

    res.json(updatedOrder);
  } catch (error) {
    logger.error(`Error updating order ${req.params.id}:`, error);
    res
      .status(500)
      .json({ error: "Error updating order", details: error.message });
  }
};

// Delete an order
exports.deleteOrder = async (req, res) => {
  logger.info(`Processing delete order request for ID: ${req.params.id}`);
  try {
    const order = await models.Order.findByPk(req.params.id);

    if (!order) {
      logger.warn(`Order not found for deletion: ${req.params.id}`);
      return res.status(404).json({ message: "Order not found" });
    }

    // Delete in transaction
    await models.sequelize.transaction(async (t) => {
      // Delete order items first
      await models.OrderItem.destroy({
        where: { OrderId: order.id },
        transaction: t,
      });

      // Delete order
      await order.destroy({ transaction: t });
    });

    logger.info(`Order ${req.params.id} deleted successfully`);
    res.json({ message: "Order deleted" });
  } catch (error) {
    logger.error(`Error deleting order ${req.params.id}:`, error);
    res.status(500).json({ error: "Error deleting order" });
  }
};
----------------------------------------

FILE: ./controllers/productController.js
----------------------------------------
const models = require("../models");
const logger = require("../utils/logger");

// Get all products
exports.getProducts = async (req, res) => {
  logger.info("Processing get all products request...");
  try {
    const products = await models.Product.findAll({
      where: { isActive: true },
      attributes: ['id', 'name', 'price', 'stock', 'description', 'image', 'category'],
    });

    logger.info(`Retrieved ${products.length} products`);
    res.json(products);
  } catch (error) {
    logger.error("Product retrieval error:", error);
    res.status(500).json({ error: "Database error" });
  }
};

// Get a specific product
exports.getProduct = async (req, res) => {
  logger.info(`Processing get product request for ID: ${req.params.id}`);
  try {
    const product = await models.Product.findByPk(req.params.id, {
      attributes: ['id', 'name', 'price', 'stock', 'description', 'image', 'category', 'dailyTarget', 'isActive'],
    });

    if (!product) {
      logger.warn(`Product not found: ${req.params.id}`);
      return res.status(404).json({ message: "Product not found" });
    }

    logger.info(`Product ${req.params.id} retrieved successfully`);
    res.json(product);
  } catch (error) {
    logger.error(`Error retrieving product ${req.params.id}:`, error);
    res.status(500).json({ error: "Database error" });
  }
};
----------------------------------------

FILE: ./index.js
----------------------------------------
const express = require("express");
const bodyParser = require("body-parser");
const cors = require("cors");
const { testConnection } = require("./config/database");
const { syncDatabase } = require("./models");
const logger = require("./utils/logger");
const loggerMiddleware = require("./middleware/loggerMiddleware");

// Import routes
const authRoutes = require("./routes/authRoutes");
const cashRoutes = require("./routes/cashRoutes");
const chatRoutes = require("./routes/chatRoutes");

const orderRoutes = require("./routes/orderRoutes");
const bakingListRoutes = require("./routes/bakingListRoutes");
const productRoutes = require("./routes/productRoutes");

const app = express();
const PORT = 5000;

// Configure middleware
app.use(
  cors({
    origin: "http://localhost:3000",
    methods: ["GET", "POST", "PUT", "DELETE"],
    allowedHeaders: ["Content-Type", "Authorization"],
  }),
);
app.use(bodyParser.json());
app.use(loggerMiddleware);

// Initialize database
logger.info("Initializing application...");
testConnection().then(async (connected) => {
  if (connected) {
    await syncDatabase();
    const productSeeder = require("./seeders/productSeeder");
    await productSeeder
      .seed()
      .catch((err) => logger.error("Error in product seeder:", err));
  } else {
    logger.error("Failed to connect to database. Exiting...");
    process.exit(1);
  }
});

// Register routes
app.use("/", authRoutes);
app.use("/cash", cashRoutes);
app.use("/chat", chatRoutes);

// Admin routes
app.use("/orders", orderRoutes);
app.use("/baking-list", bakingListRoutes);
app.use("/products", productRoutes);

// Error handling middleware
app.use((err, req, res, next) => {
  logger.error("Unhandled application error:", err);
  res.status(500).json({ error: "An unexpected error occurred" });
});

// Starting the server
app.listen(PORT, () => {
  logger.info(`Server running on http://localhost:${PORT}`);
  logger.info("Available routes:");
  logger.info("  POST /register - Register a new user");
  logger.info("  POST /login - Login a user");
  logger.info("  POST /cash - Add a cash entry (authenticated)");
  logger.info("  GET /cash - Get cash entries (authenticated)");
  logger.info("  GET /chat - Get all chat messages (authenticated)");
  logger.info("  POST /chat - Post a new chat message (authenticated)");
});
----------------------------------------

FILE: ./list_files.sh
----------------------------------------
#!/bin/bash

# Script to list all files and print their content from the current directory
# Excludes node_modules, out, .next directories and .db files

# Define output file
OUTPUT_FILE="project_files.txt"

# Create or clear the output file
echo "=== Directory Content Listing ===" > "$OUTPUT_FILE"
echo "Excluded: node_modules, out, .next directories and .db files" >> "$OUTPUT_FILE"
echo "===============================" >> "$OUTPUT_FILE"
echo >> "$OUTPUT_FILE"

# Find all files excluding specified directories, .db files, and the output file itself
find . -type f \
    -not -path "*/node_modules/*" \
    -not -path "*/out/*" \
    -not -path "*/.next/*" \
    -not -path "*/\.*" \
    -not -name "*.db" \
    -not -name "$OUTPUT_FILE" \
    | sort \
    | while read -r file; do
        echo "FILE: $file" >> "$OUTPUT_FILE"
        echo "----------------------------------------" >> "$OUTPUT_FILE"

        # Check if file is binary
        if file "$file" | grep -q "text"; then
            # It's a text file, display content
            cat "$file" 2>/dev/null >> "$OUTPUT_FILE" ||
            echo "[Error: Could not display file content]" >> "$OUTPUT_FILE"
        else
            # It's a binary file
            echo "[Binary file - content not displayed]" >> "$OUTPUT_FILE"
        fi

        echo "----------------------------------------" >> "$OUTPUT_FILE"
        echo >> "$OUTPUT_FILE"
    done

echo "Files and content have been saved to $OUTPUT_FILE"
----------------------------------------

FILE: ./middleware/authMiddleware.js
----------------------------------------
const jwt = require("jsonwebtoken");
const logger = require("../utils/logger");
const SECRET_KEY = "your_secret_key";

const authenticate = (req, res, next) => {
  logger.info("Authenticating request...");
  const token = req.headers["authorization"];

  if (!token) {
    logger.info("Authentication failed: No token provided");
    return res.status(403).json({ error: "Unauthorized" });
  }

  jwt.verify(token, SECRET_KEY, (err, decoded) => {
    if (err) {
      logger.error("Authentication failed: Invalid token", err);
      return res.status(403).json({ error: "Invalid token" });
    }

    req.userId = decoded.id;
    logger.info(`Authentication successful for user ID: ${req.userId}`);
    next();
  });
};

module.exports = { authenticate, SECRET_KEY };
----------------------------------------

FILE: ./middleware/loggerMiddleware.js
----------------------------------------
const logger = require("../utils/logger");

const loggerMiddleware = (req, res, next) => {
  logger.request(req);
  next();
};

module.exports = loggerMiddleware;
----------------------------------------

FILE: ./models/Cash.js
----------------------------------------
const { DataTypes } = require("sequelize");
const logger = require("../utils/logger");

module.exports = (sequelize) => {
  const Cash = sequelize.define(
    "Cash",
    {
      amount: {
        type: DataTypes.FLOAT,
        allowNull: false,
      },
      date: {
        type: DataTypes.DATEONLY,
        allowNull: false,
      },
    },
    {
      hooks: {
        beforeCreate: (cash) => {
          logger.info(`Creating cash entry: Amount ${cash.amount}`);
        },
      },
    },
  );

  return Cash;
};
----------------------------------------

FILE: ./models/Chat.js
----------------------------------------
const { DataTypes } = require("sequelize");
const logger = require("../utils/logger");

module.exports = (sequelize) => {
  const Chat = sequelize.define(
    "Chat",
    {
      message: {
        type: DataTypes.TEXT,
        allowNull: false,
      },
      timestamp: {
        type: DataTypes.DATE,
        allowNull: false,
      },
    },
    {
      hooks: {
        beforeCreate: (chat) => {
          logger.info(`Creating chat message from user ${chat.UserId}`);
        },
      },
    },
  );

  return Chat;
};
----------------------------------------

FILE: ./models/User.js
----------------------------------------
const { DataTypes } = require("sequelize");
const logger = require("../utils/logger");

module.exports = (sequelize) => {
  const User = sequelize.define(
    "User",
    {
      username: {
        type: DataTypes.STRING,
        unique: true,
        allowNull: false,
      },
      password: {
        type: DataTypes.STRING,
        allowNull: false,
      },
    },
    {
      hooks: {
        beforeCreate: (user) => {
          logger.info(`Creating new user: ${user.username}`);
        },
        afterCreate: (user) => {
          logger.info(`User created with ID: ${user.id}`);
        },
      },
    },
  );

  return User;
};
----------------------------------------

FILE: ./models/ai.md
----------------------------------------
# Bakery Backend Models Directory

This directory contains the Sequelize ORM models that define the database schema for the bakery application.

## Key Models

- `Product.js` - Product model representing bakery items
- `User.js` - User model for authentication and authorization
- `Cash.js` - Cash entries model for tracking financial transactions
- `Chat.js` - Chat messages model
- `Order.js` - Order model for tracking customer orders
- `OrderItem.js` - Order items model for individual items in an order

## Model Structure

The directory follows Sequelize's standard model definition pattern:

- Each model file exports a function that takes `sequelize` and `DataTypes` parameters
- Models define fields, validations, and associations
- The `index.js` file sets up associations between models

## Product Model

The `Product` model includes fields like:
- `id` - Primary key
- `name` - Product name
- `price` - Product price
- `stock` - Current inventory level
- `dailyTarget` - Daily production target
- `description` - Product description
- `isActive` - Whether the product is available
- `image` - Path to product image
- `category` - Product category

This model was recently updated to support CSV data import with new fields for images and categories.

## Database Relationships

- Users have many Cash entries
- Users have many Chat messages
- Orders have many OrderItems
- Products can be part of multiple OrderItems

## Code Style

- No semicolons
- Clear field definitions with proper types
- Default values provided where appropriate
- Associations defined in the `index.js` file

## Usage Example

```javascript
const product = await models.Product.findByPk(1);
const allActiveProducts = await models.Product.findAll({
  where: { isActive: true }
});
```----------------------------------------

FILE: ./models/index.js
----------------------------------------
const { sequelize } = require("../config/database");
const { DataTypes } = require("sequelize");
const logger = require("../utils/logger");

// Import model definitions
const UserModel = require("./User");
const CashModel = require("./Cash");
const ChatModel = require("./Chat");
const ProductModel = require("./Product");
const OrderModel = require("./order");
const OrderItemModel = require("./orderItem");

// Initialize models with DataTypes
const User = UserModel(sequelize, DataTypes);
const Cash = CashModel(sequelize, DataTypes);
const Chat = ChatModel(sequelize, DataTypes);
const Product = ProductModel(sequelize, DataTypes);
const Order = OrderModel(sequelize, DataTypes);
const OrderItem = OrderItemModel(sequelize, DataTypes);

logger.info("Setting up model relationships...");

// Define relationships
User.hasMany(Cash);
Cash.belongsTo(User);

User.hasMany(Chat);
Chat.belongsTo(User);

// Order relationships
Order.hasMany(OrderItem);
OrderItem.belongsTo(Order);

// Sync all models with database
async function syncDatabase() {
  try {
    logger.info("Attempting to sync database models...");
    await sequelize.sync();
    logger.info("Database synchronized successfully");

    // Count existing records
    const userCount = await User.count();
    const cashCount = await Cash.count();
    const chatCount = await Chat.count();
    const productCount = await Product.count();
    const orderCount = await Order.count();

    logger.info(
      `Database contains: ${userCount} users, ${cashCount} cash entries, ${chatCount} chat messages, ${productCount} products, ${orderCount} orders`,
    );
    return true;
  } catch (error) {
    logger.error("Unable to sync database:", error);
    throw error;
  }
}

module.exports = {
  sequelize,
  User,
  Cash,
  Chat,
  Product,
  Order, // Export the Order model
  OrderItem, // Export the OrderItem model
  syncDatabase,
};
----------------------------------------

FILE: ./models/order.js
----------------------------------------
module.exports = (sequelize, DataTypes) => {
  const Order = sequelize.define("Order", {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true,
    },
    customerName: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    customerPhone: {
      type: DataTypes.STRING,
    },
    customerEmail: {
      type: DataTypes.STRING,
    },
    pickupDate: {
      type: DataTypes.DATE,
      allowNull: false,
    },
    status: {
      type: DataTypes.STRING,
      defaultValue: "Pending",
    },
    notes: {
      type: DataTypes.TEXT,
    },
    totalPrice: {
      type: DataTypes.FLOAT,
      defaultValue: 0,
    },
  });

  Order.associate = (models) => {
    if (models.OrderItem) {
      Order.hasMany(models.OrderItem);
    }
  };

  return Order;
};
----------------------------------------

FILE: ./models/orderItem.js
----------------------------------------
module.exports = (sequelize, DataTypes) => {
  const OrderItem = sequelize.define("OrderItem", {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true,
    },
    productId: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    productName: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    quantity: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },
    unitPrice: {
      type: DataTypes.FLOAT,
      allowNull: false,
    },
  });

  OrderItem.associate = (models) => {
    if (models.Order) {
      OrderItem.belongsTo(models.Order);
    }
  };

  return OrderItem;
};
----------------------------------------

FILE: ./models/product.js
----------------------------------------
module.exports = (sequelize, DataTypes) => {
  const Product = sequelize.define("Product", {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true,
    },
    name: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    price: {
      type: DataTypes.FLOAT,
      allowNull: false,
    },
    stock: {
      type: DataTypes.INTEGER,
      defaultValue: 0,
    },
    dailyTarget: {
      type: DataTypes.INTEGER,
      defaultValue: 0,
    },
    description: {
      type: DataTypes.TEXT,
    },
    isActive: {
      type: DataTypes.BOOLEAN,
      defaultValue: true,
    },
    image: {
      type: DataTypes.STRING,
    },
    category: {
      type: DataTypes.STRING,
    },
  });

  return Product;
};
----------------------------------------

FILE: ./package-lock.json
----------------------------------------
[Binary file - content not displayed]
----------------------------------------

FILE: ./package.json
----------------------------------------
[Binary file - content not displayed]
----------------------------------------

FILE: ./routes/authRoutes.js
----------------------------------------
const express = require("express");
const router = express.Router();
const authController = require("../controllers/authController");

// Authentication routes
router.post("/register", authController.register);
router.post("/login", authController.login);

module.exports = router;
----------------------------------------

FILE: ./routes/bakingListRoutes.js
----------------------------------------
// bakery/backend/routes/bakingListRoutes.js
const express = require("express");
const router = express.Router();
const bakingListController = require("../controllers/bakingListController");

// Baking list route
router.get("/", bakingListController.getBakingList);

// Get Hefezopf orders
router.get("/production/hefezopf-orders", async (req, res) => {
  try {
    const { date } = req.query;

    // In a real implementation, query your database for orders
    // For now, return mock data
    const mockOrders = {
      "Hefezopf Plain": 15,
      "Hefekranz Nuss": 8,
      "Hefekranz Schoko": 12,
      "Hefekranz Pudding": 5,
      "Hefekranz Marzipan": 4,
      "Mini Hefezopf": 20,
      "Hefeschnecken Nuss": 30,
      "Hefeschnecken Schoko": 25,
    };

    res.json(mockOrders);
  } catch (error) {
    console.error("Error fetching hefezopf orders:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

// Save production plan
router.post("/production/plans", async (req, res) => {
  try {
    const { date, plan } = req.body;

    // In a real implementation, save to your database
    // For now, just acknowledge receipt

    res.json({
      success: true,
      message: "Production plan saved successfully",
      id: `plan-${Date.now()}`,
    });
  } catch (error) {
    console.error("Error saving production plan:", error);
    res.status(500).json({ error: "Failed to save production plan" });
  }
});

module.exports = router;
----------------------------------------

FILE: ./routes/cashRoutes.js
----------------------------------------
const express = require("express");
const router = express.Router();
const cashController = require("../controllers/cashController");
const { authenticate } = require("../middleware/authMiddleware");

// Cash routes (all protected)
router.post("/", authenticate, cashController.addCashEntry);
router.get("/", authenticate, cashController.getCashEntries);

module.exports = router;
----------------------------------------

FILE: ./routes/chatRoutes.js
----------------------------------------
const express = require("express");
const router = express.Router();
const chatController = require("../controllers/chatController");
const { authenticate } = require("../middleware/authMiddleware");

// Chat routes (all protected)
router.get("/", authenticate, chatController.getChatMessages);
router.post("/", authenticate, chatController.addChatMessage);

module.exports = router;
----------------------------------------

FILE: ./routes/orderRoutes.js
----------------------------------------
const express = require("express");
const router = express.Router();
const orderController = require("../controllers/orderController");

// Order CRUD routes
router.get("/", orderController.getOrders);
router.get("/:id", orderController.getOrder);
router.post("/", orderController.createOrder);
router.put("/:id", orderController.updateOrder);
router.delete("/:id", orderController.deleteOrder);

module.exports = router;
----------------------------------------

FILE: ./routes/productRoutes.js
----------------------------------------
const express = require("express");
const router = express.Router();
const productController = require("../controllers/productController");

// Product routes
router.get("/", productController.getProducts);
router.get("/:id", productController.getProduct);
// Add more routes as needed

module.exports = router;
----------------------------------------

FILE: ./seeders/ai.md
----------------------------------------
# Bakery Backend Seeders Directory

This directory contains database seeders for the bakery application. Seeders are responsible for populating the database with initial data when the application first starts or when the database is reset.

## Key Seeders

- `productSeeder.js` - Populates the Products table with data from `content/products/products.csv`

## Product Seeder

The Product Seeder has been recently updated to:

1. Read product data from a CSV file located at `content/products/products.csv`
2. Parse the CSV data using the new `csvParser.js` utility in the utils directory
3. Transform the data to match the Product model structure
4. Insert the processed data into the database using Sequelize's bulkCreate

## How Seeders Work

Seeders are executed during application startup in `index.js`. They check if data already exists in the table, and only populate it if the table is empty. This prevents duplicate data when restarting the application.

## CSV Data Structure

The product CSV file contains the following fields:
- `id` - Product identifier
- `name` - Product name
- `category` - Product category (e.g., Brot, Brötchen, Kuchen)
- `image` - Path to the product image file
- `price` - Product price in EUR

## Usage

Seeders are automatically run when the application starts. To manually trigger a seeder:

```javascript
const productSeeder = require('./seeders/productSeeder');
await productSeeder.seed();
```

## Related Files

- `utils/csvParser.js` - Parses the CSV product data
- `models/Product.js` - The database model the seeder populates
- `test-csv.js` - Test script for verifying CSV parsing functionality----------------------------------------

FILE: ./seeders/productSeeder.js
----------------------------------------
const path = require('path');
const models = require("../models");
const logger = require("../utils/logger");
const { parseCSV } = require("../utils/csvParser");

module.exports = {
  seed: async () => {
    try {
      // Check if Product model exists before trying to use it
      if (!models.Product) {
        logger.error("Product model not found. Skipping product seeding.");
        return;
      }

      const productCount = await models.Product.count();

      if (productCount === 0) {
        // Path to CSV file relative to this file
        const csvFilePath = path.resolve(__dirname, '../../content/products/products.csv');
        
        // Parse CSV data
        const productsData = parseCSV(csvFilePath);
        
        // Transform CSV data to match our model structure
        const productsToCreate = productsData.map(product => ({
          id: parseInt(product.id),
          name: product.name,
          price: parseFloat(product.price),
          description: `Category: ${product.category}`,
          // Set default values for fields not in CSV
          stock: 10,
          dailyTarget: 20,
          isActive: true,
          // Store image path from CSV
          image: product.image
        }));
        
        // Create products in database
        await models.Product.bulkCreate(productsToCreate);
        logger.info(`Created ${productsToCreate.length} products from CSV data`);
      } else {
        logger.info("Products already exist, skipping seed");
      }
    } catch (error) {
      logger.error("Error seeding products:", error);
      logger.error(error.stack);
    }
  },
};
----------------------------------------

FILE: ./test-csv.js
----------------------------------------
const path = require("path");
const { parseCSV } = require("./utils/csvParser");
const logger = require("./utils/logger");

async function main() {
  try {
    // Path to CSV file
    const csvFilePath = path.resolve(
      __dirname,
      "../content/products/products.csv",
    );

    // Parse CSV data
    const productsData = parseCSV(csvFilePath);

    // Log results
    logger.info(`Successfully parsed ${productsData.length} products from CSV`);
    logger.info("First 3 products:");

    // Log first 3 products for verification
    productsData.slice(0, 3).forEach((product, index) => {
      logger.info(`Product ${index + 1}:`, product.name);
    });

    // Transform CSV data to match our model structure (as in seeder)
    const transformedProducts = productsData.slice(0, 3).map((product) => ({
      id: parseInt(product.id),
      name: product.name,
      price: parseFloat(product.price),
      description: `Category: ${product.category}`,
      stock: 10,
      dailyTarget: 20,
      isActive: true,
      image: product.image,
      category: product.category,
    }));

    // Log transformed data
    logger.info("Transformed products:");
    transformedProducts.forEach((product, index) => {
      logger.info(
        `Transformed Product ${index + 1}:`,
        JSON.stringify(product, null, 2),
      );
    });
  } catch (error) {
    logger.error("Error testing CSV parser:", error);
  }
}

main();
----------------------------------------

FILE: ./utils/ai.md
----------------------------------------
# Bakery Backend Utils Directory

This directory contains utility functions and helpers used throughout the backend application.

## Files in this Directory

- `logger.js` - Logging utility for consistent log formatting across the application
- `csvParser.js` - CSV parsing utility for importing product data from CSV files

## CSV Parser

The `csvParser.js` file provides functionality to:
- Read CSV files from the filesystem
- Parse CSV data into JavaScript objects
- Handle quoted fields and special characters properly
- Map CSV headers to object properties

This utility is primarily used by the product seeder to import product data from the CSV file located at `content/products/products.csv`.

## Logger

The `logger.js` file provides:
- Consistent log formatting
- Different log levels (info, error, warn, debug)
- Database query logging functionality

## Usage Example

```javascript
const { parseCSV } = require('./utils/csvParser');
const logger = require('./utils/logger');

// Parse CSV file
const products = parseCSV('path/to/file.csv');

// Log results
logger.info(`Successfully parsed ${products.length} products`);
```

## Code Style

- No semicolons
- Functional programming approach
- Thorough error handling
- Clear documentation----------------------------------------

FILE: ./utils/csvParser.js
----------------------------------------
const fs = require('fs');
const path = require('path');
const logger = require('./logger');

/**
 * Parses a CSV file and returns an array of objects
 * @param {string} filePath - Path to the CSV file
 * @returns {Array} - Array of objects where each object represents a row in the CSV
 */
function parseCSV(filePath) {
  try {
    // Read file
    const data = fs.readFileSync(filePath, 'utf8');
    
    // Split the content by new line
    const lines = data.split('\n');
    
    // Extract headers
    const headers = lines[0].split(',').map(header => {
      // Remove quotes if they exist
      return header.replace(/^"/, '').replace(/"$/, '').trim();
    });
    
    // Parse data rows
    const result = [];
    for (let i = 1; i < lines.length; i++) {
      if (!lines[i].trim()) continue; // Skip empty lines
      
      const values = [];
      let insideQuotes = false;
      let currentValue = '';
      
      // Parse CSV line character by character to handle quoted fields properly
      for (let j = 0; j < lines[i].length; j++) {
        const char = lines[i][j];
        
        if (char === '"') {
          insideQuotes = !insideQuotes;
        } else if (char === ',' && !insideQuotes) {
          values.push(currentValue);
          currentValue = '';
        } else {
          currentValue += char;
        }
      }
      
      // Add the last value
      values.push(currentValue);
      
      // Create object from headers and values
      const obj = {};
      for (let j = 0; j < headers.length; j++) {
        // Remove quotes if they exist
        if (values[j]) {
          obj[headers[j]] = values[j].replace(/^"/, '').replace(/"$/, '').trim();
        } else {
          obj[headers[j]] = '';
        }
      }
      
      result.push(obj);
    }
    
    logger.info(`Successfully parsed CSV file: ${filePath}, found ${result.length} entries`);
    return result;
  } catch (error) {
    logger.error(`Error parsing CSV file: ${filePath}`, error);
    throw error;
  }
}

module.exports = {
  parseCSV
};----------------------------------------

FILE: ./utils/logger.js
----------------------------------------
const logger = {
  info: (message) => {
    console.log(`[INFO] [${new Date().toISOString()}] ${message}`);
  },
  error: (message, error) => {
    console.error(`[ERROR] [${new Date().toISOString()}] ${message}`);
    if (error) console.error(error);
  },
  db: (message) => {
    console.log(`[DB] [${new Date().toISOString()}] ${message}`);
  },
  debug: (message) => {
    console.log(`[DEBUG] [${new Date().toISOString()}] ${message}`);
  },
  request: (req) => {
    console.log(
      `[REQUEST] [${new Date().toISOString()}] ${req.method} ${req.url}`,
    );
    if (req.body && Object.keys(req.body).length > 0) {
      const sanitizedBody = { ...req.body };
      // Sanitize sensitive data
      if (sanitizedBody.password) sanitizedBody.password = "********";
      console.log("Request Body:", sanitizedBody);
    }
  },
};

module.exports = logger;
----------------------------------------

